###  什么是.NET？什么是CLI？什么是CLR？什么是CLS？什么是CTS？IL是什么？JIT是什么，它是如何工作的？GC是什么，简述一下GC的工作方式？
.Net 是微软提供的一种框架;

CLI:通用语言基础结构(Common Language Infacestructure CLI),是CLR的一个子集, 也就是.Net中最终对编译成MSIL代码的应用程序的运行环境进行管理的那一部分;
> CLI是.Net和CLR的灵魂，CLI为IL代码提供运行的环境，你可以将使用任何语言编写的代码通过其特定的编译器转换为MSIL代码之后运行其上，甚至还可以自己写MSIL代码在CLI上面运行。
> 主要包括类加载器(Class Loader)、实时编译器(IL To Native Compilers)和一个运行时环境的垃圾收集器(Garbage Collector).

CTS:通用类型系统（Common Type System），CLI的一个子集，定义了一个能够在CLR上运行的语言规范。
> 尽管有很多语言本身不符合CTS规范，但是通过加强编译器，改变语言附 加规范等手段，使得许多语言能够编写出能在CLR上运行的程序。

CLS:通用语言规范(Common Language Specification), 是CTS的一个子集，它定义了希望在 .NET上运行的程序的语言所需符合的最小规范。
> 正因为.NET允许由不同的语言编写的程序一起运行，所以才制定出CLS规范，以避免不同语言特性产生的错误。

CLR:公共语言运行时(Common Language Runtime)是一个可由多种编程语言使用的"运行时";
> CLR的核心功能（比如内存管理、程序集加载、安全性、异常处理、线程同步）可由CLR的所有语言共用。

IL:中间语言,DotNet的程序经过编译以后就形成了IL代码,在运行的时候CLR将IL编程本地CPU指令. IL代码又称为托管代码.
> IL可以访问CLR的所有功能。IL也可视为一种面向对象的机器语言，可以使用汇编语言来编写IL。IL优势在于它会验证代码的正确性（参数数量，参数类型的验证）

JIT:即时编译器(Just In Time),CLR调用,将IL编译成本地CPU指令；

GC：垃圾回收器（garbage collection）；
> DotNet 的垃圾回收分为两个步骤：第一步，进行“标记”，垃圾回收器假设所有的对象都是垃圾，然后遍历每一个“根”（根包含指向引用类型对象的一个指针，值类型对象永远不会认为是一个根），如果发现一个根引用了一个对象（非Null），就对对象进行标记，没有标记的就认为是垃圾。第二步就是“压缩”，其实就是讲后面的对象移动到已经成为垃圾的对象位置；

> GC类中的方法影响何时对对象进行垃圾回收以及何时释放对象所分配的资源。此类中的属性提供以下信息：系统可用内存总量、分配给对象的内存的周期类别（代）
> 垃圾回收由以下步骤组成：  
GC搜索托管代码中引用的托管对象。
GC尝试完成没有被引用的对象。
GC释放没有被引用的对象并回收它们的内存。

###  类（class）和结构（struct）的区别是什么？它们对性能有影响吗？.NET BCL里有哪些是类（结构），为什么它们不是结构（类）？在自定义类型时，您如何选择是类还是结构？
类是一种“引用类型”。创建类的对象时，对象赋值到的变量只保存对该内存的引用。将对象引用赋给新变量时，新变量引用的是原始对象。通过一个变量做出的更改将反映在另一个变量中，因为两者引用同一数据。
结构是一种值类型。创建结构时，结构赋值到的变量保存该结构的实际数据。将结构赋给新变量时，将复制该结构。因此，新变量和原始变量包含同一数据的两个不同的副本。对一个副本的更改不影响另一个副本。
区别:
1. 在结构声明中，除非字段被声明为 const 或 static，否则无法初始化。
2. 结构不能声明默认构造函数（没有参数的构造函数）或析构函数。
3. 结构在赋值时进行复制。
4. 结构是值类型，而类是引用类型。
5. 与类不同，结构的实例化可以不使用 new 运算符。
6. 结构可以声明带参数的构造函数。
7. 一个结构不能从另一个结构或类继承，而且不能作为一个类的基。
8. 结构可以实现接口。
9. 结构可用作可以为 null 的类型，因而可向其赋 null 值。

.NET BCL里有哪些是类（结构），为什么它们不是结构（类）？
结构:int\double\float\Datetime\Enum\decimal
类：所有的引用类型；
结构直接继承 System.ValueType,类继承于System.Object;

**在自定义类型时，您如何选择是类还是结构？**
除非满足一下所有条件，否则不要定义成值类型（结构体）
　　第一，类型具有基元类型的行为。类型简单，其中没有成员会修改类型的任何实例字段。
　　第二，类型不需要从其他任何类型继承。
　　第三，类型不会派生出其他任何类型。
　　除了满足以上全部条件，还必须满足以下条件中的一个。
　　第一，类型的实例较小（约是16字节或者更小）。
　　第二，类型实例较大，但不作为方法的实参传递，也不通过方法返回。

### 在.NET程序运行过程中，什么是堆，什么是栈？什么情况下会在堆（栈）上分配数据？它们有性能上的区别吗？“结构”对象可能分配在堆上吗？什么情况下会发生，有什么需要注意的吗？
**在.NET程序运行过程中，什么是堆，什么是栈？**
堆：托管堆（managed heap），进程初始化时，CLR要保留的一块连续的地址空间,这个地址空间最开始没有对引得物理存储空间. 这个地址空间就是托管堆;
栈: 是在程序运行过程中用于保存指令,值类型变量的内存区域(一个线程对应一个栈); 遵从先进先出原则;
**什么情况下会在堆（栈）上分配数据？它们有性能上的区别吗？**
值类型在栈上分配，引用类型在堆上分配。  
由于栈上分配数据不受垃圾回收的控制，不存在垃圾回收的各种开销，应用程序执行的时候垃圾回收的次数也会少很多，所以栈上分配显然要比堆上分配好。由于在栈上分配的变量已经包含了实例的字段所以不需要一个指针指向它。空间上的开销也较小。
**“结构”对象可能分配在堆上吗？什么情况下会发生，有什么需要注意的吗？**
值类型不会作为对象在堆中进行分配，但在许多情况下，都需要获取对值类型的一个实例引用。例如假定要建个ArrayList来容纳Point结构。
```cs
  //声明一个值类型。 
  struct Point { publicint x, y;}
  publicsealedclass Program
  {
      publicstaticvoid Main()
      {
          ArrayList a =new ArrayList(); 
          Point p; 
          for (int i =0; i <10; i++) 
          {
              p.x = p.y = i; a.Add(p); 
          }
      }
  }
```
这个时候 Point 值类型必须转换成一个真正 的，在堆中托管的对象，而且必须 获取对这个对象的引用。 这就是装箱的机制。 
此时要注意，这样的操作会产生 装箱/拆箱操作; 可以使用泛型集合,泛型可以避免值类型发生装箱操作;

### 泛型的作用是什么？它有什么优势？它对性能有影响吗？它在执行时的行为是什么？.NET BCL中有哪些泛型类型？举例说明平时编程中您定义的泛型类型。
作用:提高代码复用率;
优势:
1. 源代码保护;（如果你知道C++模板对泛型的实现机制，就会知道C++在编译的时候根据对泛型的调用，自动“内联”了一个实现，这样泛型的内容就暴露了，尔DotNet的实现方式就不同了，泛型类和方法会被编译成IL，在执行的时候由JIT负责将IL变化为指定类型参数的本地代码，从而保护了源代码；使用.net一个泛型的算法的开发人员不需要访问算法的源代码。然而使用C++模板的泛型技术时，算法的源代码必须提供给准备使用算法的用户。）
2. 类型安全。（这点是最显而易见的，抛弃了使用ArrayList时各种丑陋的强制类型转换）
3. 更清晰地代码。因为没有了强制类型转换，所以代码自然显得更清晰，但是使用泛型时候带来的<>有时候确实也会让人搞糊涂，幸好泛型方法可以用类型推断或者using语句来进一步简化写法。
4. 更好的性能，因为值类型可以避免装箱和拆箱所带来的损耗（垃圾回收的次数也会减少）。（这点正是泛型神奇的地方，开发历史上抽象能力的上升往往意味着性能的下降，但是泛型却不是！泛型抽象了算法，但是C++和DotNet对泛型的实现能够让性能无损，并且更快。Java的擦除法泛型就没有这种性能上的好处。）
**它对性能有影响吗？**
对性能有积极性的影响，因为值类型可以避免装箱、拆箱操作，避免了垃圾回收，从而使性能得到显著提高；对引用类型的影响不明显；
但是需要注意的是首次为一个特定数据类型调用方法时，CLR都会为这个方法生成本地代码。这会增大应用程序的工作集大小，从而影响性能。
**它在执行时的行为是什么？**
使用泛型的方法在CLR调用JIT进行编译时，用指定的类型实参替换占位符，然后创建本地CPU指令；
需要注意的是，值类型会为每种类型生成一份独立的类型代码，而引用类型是共享代码的，
** .NET BCL中有哪些泛型类型？**
List，Dictionary、Queue（前三者我比较常用）、Stack、SortedList和SortedDictionary、LinkedList等等
**举例说明平时编程中您定义的泛型类型。**
泛型的出现会替换原来一部分使用多态的地方从而提高性能和带来更好的编译时检查，这样就不需要在子类和超类（接口）间频繁转换了。比如你要根据情况打出各种报表，那么先把报表类定义成泛型类从而可以共享报表一系列的算法。

### 异常的作用是什么？.NET BCL中有哪些常见的异常？在代码中您是如何捕获/处理异常的？在“catch (ex)”中，“throw”和“throw ex”有什么区别？您会如何设计异常的结构，什么情况下您会抛出异常？
**异常的作用是什么？**
处理系统级或应用级的错误状态，若未使用异常处理，程序在无法继续执行时将会直接抛出错误码以及错误信息；
相比直接抛出错误码的优缺点：
优点：可以将“成功场景”剥离，使代码更加清晰流畅；
缺点：无法将异常位置直接显示，但是异常会有堆栈跟踪，可以根据程序跟踪错误位置；
错误是指 程序有违背 “主成功场景” 的 “异常场景”；
异常是指 程序不能完成其名字所表示功能时的错误。
**.NET BCL中有哪些常见的异常？**
最著名的恐怕就是那句像绕口令一样的“未将对象引用设置到对象实例”了，还有那些基本一出现整个应用程序就被判死刑的“堆栈溢出”、“内存无法分配”异常了。
**在代码中您是如何捕获/处理异常的？**
使用Catch抓住异常，然后通过回滚数据库来进行事务处理；
**在“catch (ex)”中，“throw”和“throw ex”有什么区别？**
throw 重新抛出异常但是不破坏异常发生的调用栈，而“throw ex”会重置调用栈这样捕获异常的人会以为代码出错在这里。
**您会如何设计异常的结构，什么情况下您会抛出异常？**
首先尽量的使用系统定义的那些异常，如果需要处理某一特定类别的异常，而且处理方式和通常处理方式不同那么就考虑自定义异常，还有如果需要调用方用一种统一的方式来处理异常，那么自定义异常就是一个好的选择。结构使用 Sysytem.Exception作为基类，尽量使用扁平化异常的层次。可以考虑用泛型类来定义异常。　
代码无法完成名字所说明的功能，那么抛出异常；

### List<T>和T[]的区别是什么，平时你如何进行选择？Dictionary<TKey, TValue>是做什么的？.NET BCL中还有哪些常用的容器？它们分别是如何实现的（哪种数据结构）？分别是适用于哪些场景？
**List<T>和T[]的区别是什么，平时如何进行选择？**
List<T> :是一个可以定义成无限长度的泛型列表,是用一块连续的内存来存储元素，这就是为什么可通过Index直接高效访问。它有一个属性叫Capacity，可认为是当前内存块的大小。和Array相比，它的好处在于当总数超过当前Capacity时，List自动申请一块更大的内存，把当前的所有元素都Copy过去。这个过程对于程序员来说是透明的，但是也是必须了解的，因为如果在最初List初始化时给予一个合适的大小会提高程序效率，申请和复制内存是非常低效的，元素越多效率越低。；
T[]：是一个泛型的数组，数组你在定义的时候不得不给他定义长度,不够灵活。
一般使用List，无长度限制，可根据需求进行自动增加，使用更加方便，自带方法更多；
**Dictionary<TKey, TValue>是做什么的？**
字典的泛型类，对应于原来的HashTable；
**.NET BCL中还有哪些常用的容器？它们分别是如何实现的（哪种数据结构）？分别是适用于哪些场景？**
除了上面提到的两个最最常用的List和Dictionary外还有如下容器：
Queue和Stack，两者都是不允许随机访问的列表，Queue是先进先出的队列，Stack是先进后出的栈。
SortedList和SortedDictionary，两者都在枚举的时候返回一个按照Key排好序的列表，区别在于前者使用较少的内存，而后者在添加项的时候会快一些，但是如果本来就是排好序并依次添加那么前者更快。
LinkedList，是一个链表，这个集合没有对应的非泛型版本，使用一个链表是为了在其中轻松的插入一个元素，随机访问性能要比数组慢，空间占用也更多一些，它和List不同之处在于它没有预分配容量来用作扩充，所以也就没有“浪费”的空间。如果你需要能在头尾都能够快速插入或者在中部插入，并且顺序的输出，那么链表还是有用的。

### 抽象类和接口有什么区别？使用时有什么需要注意的吗？如何选择是定义一个“完全抽象”的抽象类，还是接口？什么是接口的“显式实现”？为什么说它很重要？
答案详细论述：https://www.jianshu.com/p/cc3850d7b5e2

声明方法的存在而不去实现它的类被叫做抽象类（abstract）；
抽象类不能实例化；
抽象类的用途是提供多个派生类可共享的基类的公共定义；
抽象类可以定义抽象方法；
抽象类的派生类必须实现抽象类的所有抽象方法；
抽象方法没有实现，所以抽象方法定义后面是分号，而不是方法块；

接口（Interface）是抽象类的一个变体，实现接口的任何非抽象类型都必须实现接口的所有成员；
不能直接实例化接口；
接口可以包含事件、索引器、方法和属性；
接口不包含方法的实现；
类和结构可以继承多个接口；
接口自身可从多个接口继承；

**如何选择定义一个 “完全抽象” 的抽象类，还是接口？**

抽象类是从一系列相关对象中抽象出来的概念，反映的是事务的内部共性；体现了一种继承关系，要想使得继承关系合理，**父类和派生类之间必须存在"is a"关系，即父类和子类在概念本质上应该是相同的。**
体现了数据抽象的思想，是实现多态的一种机制。
它定义了一组抽象的方法，至于这组抽象方法的具体表现形式有派生类来实现。同时抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。
所以说定义的抽象类一定是用来继承的，同时在一个以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类。

接口是为了满足外部调用而定义的一个功能，反映的事物的外部特性；不要求interface的实现者和interface定义在概念本质上是一致的，**仅仅是实现了interface定义的契约而已**。

### 字符串是引用类型类型还是结构类型？它和普通的引用类型相比有什么特别的地方吗？使用字符串时有什么需要注意的地方？为什么说StringBuilder比较高效？在连接多个字符串时，它无论何时都比直接相加更高效吗？

### 如何高效地进行数组复制？“二维数组”和“数组的数组”有什么区别？在使用双重循环遍历一个二维数组时，如何选择内外层的遍历顺序？

### 什么是元编程，.NET有哪些元编程的手段和场景？什么是反射？能否举一些反射的常用场景？有人说反射性能较差，您怎么看待这个问题？有什么办法可以提高反射的性能吗？
元编程：一种语言本来做不到的事情，通过你编程来修改它，使得它可以做到了，这就是元编程。
手段：Attribute、Reflection、CodeDom和IL Emitter；
反射（Reflection）：程序可以访问、检测和修改它本身状态或者行为的一种能力；程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象；
常用场景：orm框架；
优缺点：
- 优点：
    1. 提高了程序的灵活性以及扩展性；
    2. 降低耦合性,提高自适应能力;
    3. 他允许程序创建和控制任何类的对象,无需提前硬编码目标类;
- 缺点:
    1. 性能问题:使用反射基本上是一种解释操作,用于字段和方法接入时要远慢与直接使用代码. 因此反射主要用于对于灵活性及拓展性要求很高的系统框架上,普通程序不建议使用;
    2. 使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。

优化方案:使用缓存


### 委托是什么？匿名方法是什么？在C#### 3.0中，Lambda表达式是什么？扩展方法是什么？LINQ是什么？您觉得C#### 3.0中还有哪些重要的特性，它们带来了什么优势？BCL中哪些类库和这些特性有关？您平时最常用哪些？
委托(delegate):函数指针;委托可以把一个方法作为参数传递给另一个方法;可以理解为指向一个函数的引用;
匿名方法(Anonymous methods):提供了一种传递代码块作为委托参数的技术. 匿名方法是没有名称只有主体的方法, 使用时不需要定义返回值,它由方法块内部的return决定;
Lambda表达式: 是一个匿名函数,是一种高效的类似函数式编程的表达式;
扩展方法:扩展方法是一种特殊的静态方法,可以像扩展类型上的实例方法一样使用; 最常见的扩展方法就是 linq 标准查询运算符；
LINQ：语言集成查询（LINQ）是一系列将查询功能集成到C#语言的一种技术统称；


### 工作之外您看哪些技术相关的书、网站、社区、项目等等？您还接触哪些.NET以外的技术，能和.NET或.NET中有针对性的部分做个对比吗？
